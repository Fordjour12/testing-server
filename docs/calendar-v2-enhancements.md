# Calendar V2 Enhancements - Implementation Plan

---

## Quick Architecture Decision Required

Before implementing V2, we need to clarify the **task data model**:

**Current Model:** Tasks are tied to `monthly_plans` (AI-generated)
**Question:** Should users be able to:

- **A)** Add tasks to existing monthly plans?
- **B)** Create independent user tasks outside of AI plans?
- **C)** Both (independent + plan-linked)?

*This decision affects: Task creation, rescheduling, and notes features*

---

## V2 Feature Breakdown by Priority

### Priority 1: Task Rescheduling Modal ⭐⭐⭐

**Complexity:** Medium | **Estimated:** 2-3 days

**Why High Priority:**

- Users will want to move tasks generated by AI
- Alternative to drag & drop (easier to implement first)
- Addresses core calendar pain point

**Backend:**

```sql
-- No new table needed, reuse plan_tasks table
```

```typescript
// packages/db/src/queries/calendar.ts
export async function rescheduleTask(
  taskId: number,
  newStartTime: Date,
  newEndTime: Date
) {
  const [updatedTask] = await db
    .update(planTasks)
    .set({
      startTime: newStartTime,
      endTime: newEndTime
    })
    .where(eq(planTasks.id, taskId))
    .returning();
  return updatedTask;
}
```

```typescript
// packages/api/src/routers/calendar.ts
calendarRouter.patch('/tasks/:taskId/reschedule', zValidator('json', z.object({
  newStartTime: z.string(),
  newEndTime: z.string()
})), async (c) => {
  try {
    const taskId = parseInt(c.req.param('taskId'));
    const { newStartTime, newEndTime } = c.req.valid('json');
    const session = c.get('session');

    if (!session?.user?.id) {
      return c.json({ error: 'Authentication required' }, 401);
    }

    const updatedTask = await rescheduleTask(
      taskId,
      new Date(newStartTime),
      new Date(newEndTime)
    );

    return c.json({ success: true, data: updatedTask });
  } catch (error) {
    console.error('Error rescheduling task:', error);
    return c.json({
      success: false,
      error: 'Failed to reschedule task'
    }, 500);
  }
});
```

**Implementation:**

1. Add `rescheduleTask()` query to `packages/db/src/queries/calendar.ts`
2. Add API route with validation
3. Add server function
4. Add "Reschedule" button in `TaskDetailSheet` (next to checkbox)
5. Create `TaskRescheduleDialog` component:
   - Date picker
   - Time range picker
   - Reason field (optional)
   - Save/Cancel buttons

**UI Flow:**

```txt
Task → Click Reschedule → Dialog Opens → Pick New Date/Time → Confirm → Update
```

---

### Priority 2: Full Task Creation Modal ⭐⭐

**Complexity:** High | **Estimated:** 3-4 days

**Note:** Depends on **Architecture Decision** above

**If Option A (add to existing plan):**

```sql
-- No schema change needed
```

```typescript
// packages/api/src/routers/calendar.ts
calendarRouter.post('/tasks', zValidator('json', z.object({
  planId: z.number().optional(), // Optional: use current month's plan if not provided
  taskDescription: z.string().min(1),
  focusArea: z.string().min(1),
  startTime: z.string(), // ISO 8601
  endTime: z.string(),
  difficultyLevel: z.enum(['simple', 'moderate', 'advanced'])
})), async (c) => {
  try {
    const { planId, taskDescription, focusArea, startTime, endTime, difficultyLevel } = c.req.valid('json');
    const session = c.get('session');

    if (!session?.user?.id) {
      return c.json({ error: 'Authentication required' }, 401);
    }

    const userId = session.user.id;

    // If planId not provided, find user's current month's plan
    let targetPlanId = planId;
    if (!targetPlanId) {
      const currentMonth = new Date();
      const monthYear = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}-01`;
      const [existingPlan] = await getCurrentMonthlyPlan(userId, monthYear);
      if (existingPlan) {
        targetPlanId = existingPlan.id;
      } else {
        return c.json({ error: 'No active plan for this month' }, 400);
      }
    }

    const newTask = await createPlanTask({
      planId: targetPlanId,
      taskDescription,
      focusArea,
      startTime: new Date(startTime),
      endTime: new Date(endTime),
      difficultyLevel,
      isCompleted: false
    });

    return c.json({ success: true, data: newTask });
  } catch (error) {
    console.error('Error creating task:', error);
    return c.json({
      success: false,
      error: 'Failed to create task'
    }, 500);
  }
});
```

**If Option B (independent tasks):**

```sql
-- Create new table
CREATE TABLE user_tasks (
  id SERIAL PRIMARY KEY,
  userId TEXT NOT NULL REFERENCES user(id),
  taskDescription TEXT NOT NULL,
  focusArea VARCHAR(50),
  startTime TIMESTAMP NOT NULL,
  endTime TIMESTAMP NOT NULL,
  difficultyLevel VARCHAR(20),
  isCompleted BOOLEAN DEFAULT FALSE,
  completedAt TIMESTAMP,
  notes TEXT,
  createdAt TIMESTAMP DEFAULT NOW()
);

-- Update queries to include user_tasks in results
```

**Implementation:**

1. Database schema update (new table if Option B, or none if Option A)
2. API endpoint for task creation with validation
3. Validation rules (required fields, reasonable times, no overlap check)
4. `TaskCreationDialog` component:
   - Title input
   - Description textarea
   - Date picker (pre-fill from selected day)
   - Time range picker
   - Focus area dropdown
   - Difficulty selector
   - Save/Cancel buttons

**UI Changes:**

- Change sidebar "Create Tasks" button to open modal
- Change "No tasks for this day" CTA to open modal

**File Structure:**

```code
apps/web/src/components/calendar/
├── task-creation-dialog.tsx (new)
└── task-reschedule-dialog.tsx (new)
```

---

### Priority 3: Weekly View Option ⭐

**Complexity:** Medium | **Estimated:** 2-3 days

**Why Important:**

- Alternative to monthly view for better task density
- Industry standard for calendars

**Backend:** No changes needed (same task endpoints)

**Frontend:**

1. Add view toggle: `['month', 'week']` state
2. Create `WeekCalendarGrid` component:
   - 7 columns (days of week)
   - 4-5 rows (weeks in month)
   - Horizontal/vertical week navigation
3. Update calendar page header with view switcher

**Data Challenges:**

- Week boundaries across months (e.g., Wed Jan 31 to Feb 6)
- Need week range query or smart date calculation

**Week Calendar Component:**

```typescript
// apps/web/src/components/calendar/week-calendar-grid.tsx
export function WeekCalendarGrid({
  tasks,
  selectedDate,
  onDateSelect,
  onWeekChange
}: WeekCalendarProps) {
  const weeksInMonth = React.useMemo(() => {
    // Calculate weeks for month
    // Handle partial weeks at start/end
  }, [selectedDate, tasks]);

  return (
    <div className="grid grid-cols-7 gap-2">
      {/* Header row */}
      {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
        <div key={day} className="text-center font-medium">{day}</div>
      ))}

      {/* Week rows */}
      {weeksInMonth.map((week, weekIndex) => (
        <div key={weekIndex} className="contents">
          {week.map((date, dayIndex) => (
            <DayCell date={date} tasks={getTasksForDay(date)} />
          ))}
        </div>
      ))}
    </div>
  );
}
```

**UI Changes:**

```typescript
// apps/web/src/components/calendar/page.tsx
const [viewMode, setViewMode] = useState<'month' | 'week'>('month');

// In header, add:
<ViewToggle
  value={viewMode}
  onChange={setViewMode}
  options={[
    { value: 'month', label: 'Month' },
    { value: 'week', label: 'Week' }
  ]}
/>

// Conditional render:
{viewMode === 'month' ? (
  <TaskCalendarGrid {...props} />
) : (
  <WeekCalendarGrid {...props} />
)}
```

---

### Priority 4: Export to .ics (iCalendar) ⭐

**Complexity:** Medium | **Estimated:** 2 days

**Why Valuable:**

- Integration with Google Calendar, Outlook, Apple Calendar
- One-time feature, low maintenance

**Backend Implementation:**

```typescript
// packages/api/src/routers/calendar.ts
calendarRouter.get('/export', zValidator('query', z.object({
  month: z.string().optional()
})), async (c) => {
  try {
    const { month } = c.req.valid('query');
    const session = c.get('session');

    if (!session?.user?.id) {
      return c.json({ error: 'Authentication required' }, 401);
    }

    const userId = session.user.id;
    const [year, monthNum] = month ? month.split('-').map(Number) : [undefined, undefined];

    let startDate, endDate;
    if (year && monthNum) {
      startDate = new Date(year, monthNum - 1, 1);
      endDate = new Date(year, monthNum, 0);
    } else {
      // Export all user tasks
      const [allTasks] = await db
        .select({ startTime: planTasks.startTime })
        .from(planTasks)
        .innerJoin(monthlyPlans, eq(planTasks.planId, monthlyPlans.id))
        .where(eq(monthlyPlans.userId, userId));

      if (allTasks.length === 0) {
        return c.text('BEGIN:VCALENDAR\nEND:VCALENDAR', {
          headers: { 'Content-Type': 'text/calendar; charset=utf-8' }
        });
      }

      const minDate = allTasks.reduce((min, t) => t.startTime < min ? t.startTime : min, allTasks[0].startTime);
      const maxDate = allTasks.reduce((max, t) => t.startTime > max ? t.startTime : max, allTasks[0].startTime);
      startDate = minDate;
      endDate = new Date(maxDate.getTime() + 30 * 24 * 60 * 60 * 1000);
    }

    const tasks = await getTasksByDateRange(userId, startDate, endDate);
    const icsContent = generateICS(tasks);

    return c.text(icsContent, {
      headers: {
        'Content-Type': 'text/calendar; charset=utf-8',
        'Content-Disposition': `attachment; filename="calendar-${month || 'all'}.ics"`
      }
    });
  } catch (error) {
    console.error('Error exporting calendar:', error);
    return c.json({
      success: false,
      error: 'Failed to export calendar'
    }, 500);
  }
});
```

```typescript
// packages/api/src/lib/ics-generator.ts
export function generateICS(tasks: CalendarTask[]): string {
  const lines = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//AIPlanner//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
  ];

  tasks.forEach(task => {
    lines.push('BEGIN:VEVENT');
    lines.push(`SUMMARY:${task.taskDescription}`);
    lines.push(`DTSTART:${formatICSTime(task.startTime)}`);
    lines.push(`DTEND:${formatICSTime(task.endTime)}`);
    lines.push(`DESCRIPTION:${task.focusArea} • ${task.difficultyLevel}`);
    lines.push('STATUS:' + (task.isCompleted ? 'COMPLETED' : 'NEEDS-ACTION'));
    lines.push('END:VEVENT');
  });

  lines.push('END:VCALENDAR');

  return lines.join('\r\n');
}

function formatICSTime(date: Date): string {
  return date.toISOString().replace(/[-:]/g, '').slice(0, 15) + 'Z';
}
```

**Frontend:**

- Add "Export" button in calendar header
- Download file with filename `calendar-2024-12.ics`

```typescript
// apps/web/src/components/calendar/page.tsx
const handleExport = async () => {
  const monthParam = format(selectedMonth, 'yyyy-MM');
  const response = await fetch(`/api/calendar/export?month=${monthParam}`);

  if (response.ok) {
    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `calendar-${monthParam}.ics`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
  }
};

// In header:
<Button
  variant="outline"
  size="icon"
  onClick={handleExport}
>
  <Download className="h-4 w-4" />
</Button>
```

---

### Priority 5: Task Notes/Attachments

**Complexity:** High | **Estimated:** 3-4 days

**Database:**

```sql
ALTER TABLE plan_tasks ADD COLUMN notes TEXT;
ALTER TABLE plan_tasks ADD COLUMN attachments JSONB;
```

**API:** No new endpoints needed (extend existing update query)

```typescript
// packages/db/src/queries/plan-tasks.ts (extend updateTaskStatus)
export async function updateTask(
  taskId: number,
  updates: Partial<{
    taskDescription?: string;
    focusArea?: string;
    startTime?: Date;
    endTime?: Date;
    difficultyLevel?: string;
    isCompleted?: boolean;
    completedAt?: Date | null;
    notes?: string;
    attachments?: any;
  }>
) {
  const [updatedTask] = await db
    .update(planTasks)
    .set(updates)
    .where(eq(planTasks.id, taskId))
    .returning();
  return updatedTask;
}
```

**UI:**

- Expand task detail sheet to show notes section
- Add "Edit Notes" button (opens small dialog or inline edit)
- Attachments: Show file list, add upload button

**File Storage Decision Required:**

- **Option A:** Local `uploads/` directory
  - Pros: Simple, no external dependencies
  - Cons: Limited to single server, disk space

- **Option B:** AWS S3 / Cloudflare R2 / Bunny CDN
  - Pros: Scalable, CDN delivery
  - Cons: External dependency, cost

```typescript
// apps/web/src/components/calendar/task-detail-sheet.tsx (enhanced)
<div className="space-y-4">
  {/* Task info */}
  {/* Notes section */}
  <div className="border rounded-lg p-4">
    <h4 className="font-medium mb-2">Notes</h4>
    {task.notes ? (
      <p className="text-sm text-muted-foreground">{task.notes}</p>
    ) : (
      <Button
        variant="ghost"
        size="sm"
        onClick={() => setEditingNotes(true)}
      >
        <Edit className="h-4 w-4 mr-2" />
        Add Notes
      </Button>
    )}
  </div>

  {/* Attachments section */}
  <div className="border rounded-lg p-4">
    <h4 className="font-medium mb-2">Attachments</h4>
    <input
      type="file"
      multiple
      onChange={handleFileUpload}
      className="hidden"
      id="file-upload"
    />
    <Button
      variant="outline"
      size="sm"
      onClick={() => document.getElementById('file-upload')?.click()}
    >
      <Upload className="h-4 w-4 mr-2" />
      Upload Files
    </Button>

    {task.attachments && task.attachments.length > 0 && (
      <div className="space-y-2 mt-2">
        {task.attachments.map((file, i) => (
          <div key={i} className="flex items-center justify-between p-2 bg-muted rounded">
            <span className="text-sm">{file.name}</span>
            <Button
              variant="ghost"
              size="icon"
              onClick={() => deleteAttachment(file.id)}
            >
              <Trash2 className="h-4 w-4" />
            </Button>
          </div>
        ))}
      </div>
    )}
  </div>
</div>
```

**Upload Handler:**

```typescript
const handleFileUpload = async (files: FileList) => {
  const formData = new FormData();
  Array.from(files).forEach(file => {
    formData.append('files', file);
  });

  const response = await fetch(`/api/calendar/tasks/${taskId}/attachments`, {
    method: 'POST',
    body: formData
  });

  if (response.ok) {
    const result = await response.json();
    onTaskUpdate?.();
  }
};
```

---

### Priority 6: Recurring Tasks

**Complexity:** High | **Estimated:** 4-5 days

**Database:**

```sql
CREATE TABLE recurring_tasks (
  id SERIAL PRIMARY KEY,
  userId TEXT NOT NULL REFERENCES user(id),
  title TEXT NOT NULL,
  focusArea VARCHAR(50),
  recurrenceType VARCHAR(20) NOT NULL, -- 'daily', 'weekly', 'monthly', 'custom'
  recurrenceInterval INTEGER, -- Every X days/weeks
  startDate DATE NOT NULL,
  endDate DATE, -- Optional: when to stop
  lastGenerated TIMESTAMP, -- Track last expansion into plan_tasks
  config JSONB, -- Custom rules (e.g., "first Monday of month")
  createdAt TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_recurring_user ON recurring_tasks(userId);
```

**Backend:**

- Cron job or scheduled task to expand recurring tasks into `plan_tasks`
- Query: `getDueRecurringTasks()` → generates tasks for next occurrence
- Config examples: "Every Monday", "First of month", "Every 2 weeks"

```typescript
// packages/db/src/queries/recurring.ts
export async function getDueRecurringTasks() {
  const now = new Date();

  const recurringTasks = await db
    .select()
    .from(recurringTasks)
    .where(lte(recurringTasks.startDate, now))
    .where(or(
      isNull(recurringTasks.endDate),
      gte(recurringTasks.endDate, now)
    ));

  const newPlanTasks = [];

  for (const recurring of recurringTasks) {
    let nextOccurrence = calculateNextOccurrence(recurring, now);
    const { lastGenerated, config } = recurring;

    // Skip if already generated this occurrence
    if (lastGenerated && lastGenerated >= nextOccurrence) {
      continue;
    }

    // Find or create monthly plan for the task's month
    const monthYear = `${nextOccurrence.getFullYear()}-${String(nextOccurrence.getMonth() + 1).padStart(2, '0')}-01`;
    let [plan] = await getCurrentMonthlyPlan(recurring.userId, monthYear);

    if (!plan) {
      plan = await createMonthlyPlan({
        userId: recurring.userId,
        preferenceId: 0, // Default preference for recurring tasks
        monthYear,
        aiPrompt: `Auto-generated from recurring task: ${recurring.title}`,
        aiResponseRaw: { monthly_summary: 'Recurring task expansion' },
        monthlySummary: 'Tasks from recurring schedule'
      });
    }

    newPlanTasks.push({
      planId: plan.id,
      taskDescription: recurring.title,
      focusArea: recurring.focusArea,
      startTime: nextOccurrence,
      endTime: new Date(nextOccurrence.getTime() + 2 * 60 * 60 * 1000), // Default 2 hours
      difficultyLevel: 'moderate',
      isCompleted: false
    });

    // Update lastGenerated timestamp
    await db
      .update(recurringTasks)
      .set({ lastGenerated: now })
      .where(eq(recurringTasks.id, recurring.id));
  }

  // Batch insert new tasks
  if (newPlanTasks.length > 0) {
    await createPlanTasks(newPlanTasks);
  }

  return newPlanTasks;
}

function calculateNextOccurrence(recurring: any, baseDate: Date): Date {
  const { recurrenceType, recurrenceInterval, startDate, config } = recurring;

  switch (recurrenceType) {
    case 'daily':
      // Find next day after baseDate
      return new Date(startDate);

    case 'weekly':
      // Next occurrence after baseDate
      const dayOfWeek = startDate.getDay();
      let next = new Date(baseDate);
      while (next.getDay() !== dayOfWeek) {
        next.setDate(next.getDate() + 1);
      }
      return next;

    case 'monthly':
      // Same day number, next month
      const day = startDate.getDate();
      let next = new Date(baseDate);
      next.setMonth(next.getMonth() + 1);
      next.setDate(Math.min(day, new Date(next.getFullYear(), next.getMonth() + 1, 0).getDate()));
      return next;

    case 'custom':
      // Parse config JSON for custom rules
      if (config?.weeks) {
        const weeks = parseInt(config.weeks);
        const next = new Date(baseDate.getTime() + weeks * 7 * 24 * 60 * 60 * 1000);
        return next;
      }
      return startDate;

    default:
      return startDate;
  }
}
```

**Cron Job Setup:**

```typescript
// Add to apps/server/src/index.ts or create separate cron file
import { getDueRecurringTasks } from '@testing-server/db';

// Run every hour to expand due recurring tasks
// Or run daily at midnight
cron.schedule('0 * * * *', async () => {
  console.log('Expanding recurring tasks...');
  try {
    await getDueRecurringTasks();
  } catch (error) {
    console.error('Error expanding recurring tasks:', error);
  }
});
```

**UI:**

- Task creation dialog: "Make Recurring" toggle
- When enabled: Show recurrence options
- Calendar indicator: Show recurring icon (e.g., ↻)
- Edit recurrence via task detail sheet

```typescript
// apps/web/src/components/calendar/task-creation-dialog.tsx (enhanced)
const [isRecurring, setIsRecurring] = useState(false);
const [recurrenceType, setRecurrenceType] = useState<'daily' | 'weekly' | 'monthly' | 'custom'>('weekly');

{isRecurring && (
  <div className="space-y-4 border-t pt-4">
    <h4 className="font-medium">Recurrence</h4>

    <div className="grid grid-cols-2 gap-2">
      <Button
        variant={recurrenceType === 'daily' ? 'default' : 'outline'}
        onClick={() => setRecurrenceType('daily')}
      >
        <CalendarIcon className="h-4 w-4 mr-2" />
        Daily
      </Button>

      <Button
        variant={recurrenceType === 'weekly' ? 'default' : 'outline'}
        onClick={() => setRecurrenceType('weekly')}
      >
        RepeatIcon className="h-4 w-4 mr-2" />
        Weekly
      </Button>

      <Button
        variant={recurrenceType === 'monthly' ? 'default' : 'outline'}
        onClick={() => setRecurrenceType('monthly')}
      >
        CalendarDays className="h-4 w-4 mr-2" />
        Monthly
      </Button>

      <Button
        variant={recurrenceType === 'custom' ? 'default' : 'outline'}
        onClick={() => setRecurrenceType('custom')}
      >
        Settings className="h-4 w-4 mr-2" />
        Custom
      </Button>
    </div>

    {recurrenceType === 'weekly' && (
      <Select value={recurrenceInterval} onValueChange={setRecurrenceInterval}>
        <SelectItem value="1">Every week</SelectItem>
        <SelectItem value="2">Every 2 weeks</SelectItem>
        <SelectItem value="4">Every 4 weeks</SelectItem>
      </Select>
    )}

    <div>
      <Label>End Date (Optional)</Label>
      <DatePicker
        value={endDate}
        onChange={setEndDate}
        placeholder="No end date"
      />
    </div>
  </div>
)}
```

---

### Priority 7: Calendar Sharing

**Complexity:** High | **Estimated:** 4-5 days

**Database:**

```sql
CREATE TABLE calendar_shares (
  id SERIAL PRIMARY KEY,
  userId TEXT NOT NULL REFERENCES user(id),
  shareToken UUID UNIQUE NOT NULL DEFAULT gen_random_uuid(),
  name TEXT NOT NULL, -- e.g., "Work Calendar 2024"
  permissions JSONB NOT NULL, -- { view: true, edit: false, delete: false }
  expiresAt TIMESTAMP,
  createdAt TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_shares_token ON calendar_shares(shareToken);
CREATE INDEX idx_shares_user ON calendar_shares(userId);
```

**API:**

```typescript
// packages/api/src/routers/calendar.ts
calendarRouter.post('/share', zValidator('json', z.object({
  name: z.string().min(1),
  permissions: z.object({
    view: z.boolean().default(true),
    edit: z.boolean().default(false),
    delete: z.boolean().default(false)
  }),
  expiresDays: z.number().min(1).max(365).default(30)
})), async (c) => {
  try {
    const { name, permissions, expiresDays } = c.req.valid('json');
    const session = c.get('session');

    if (!session?.user?.id) {
      return c.json({ error: 'Authentication required' }, 401);
    }

    const userId = session.user.id;
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + expiresDays);

    const [share] = await db
      .insert(calendarShares)
      .values({
        userId,
        name,
        permissions: JSON.stringify(permissions),
        expiresAt
      })
      .returning();

    return c.json({ success: true, data: share });
  } catch (error) {
    console.error('Error creating share:', error);
    return c.json({
      success: false,
      error: 'Failed to create share'
    }, 500);
  }
});

calendarRouter.get('/share/:token', async (c) => {
  try {
    const { token } = c.req.param('token');

    const [share] = await db
      .select({
        userId: calendarShares.userId,
        permissions: calendarShares.permissions,
        expiresAt: calendarShares.expiresAt,
        name: calendarShares.name
      })
      .from(calendarShares)
      .where(eq(calendarShares.shareToken, token))
      .limit(1);

    if (!share) {
      return c.json({ error: 'Share not found or expired' }, 404);
    }

    if (new Date() > share.expiresAt) {
      return c.json({ error: 'Share has expired' }, 410);
    }

    // Get shared calendar data
    const tasks = await getTasksByDateRange(
      share.userId,
      new Date(share.expiresAt.getTime() - 365 * 24 * 60 * 60 * 1000), // Max 1 year lookback
      share.expiresAt
    );

    const permissions = typeof share.permissions === 'string'
      ? JSON.parse(share.permissions)
      : share.permissions;

    return c.json({
      success: true,
      data: {
        name: share.name,
        permissions,
        tasks,
        canEdit: permissions.edit || false,
        canDelete: permissions.delete || false
      }
    });
  } catch (error) {
    console.error('Error fetching share:', error);
    return c.json({
      success: false,
      error: 'Failed to fetch shared calendar'
    }, 500);
  }
});

calendarRouter.delete('/share/:token', async (c) => {
  try {
    const { token } = c.req.param('token');
    const session = c.get('session');

    if (!session?.user?.id) {
      return c.json({ error: 'Authentication required' }, 401);
    }

    const userId = session.user.id;

    await db
      .delete(calendarShares)
      .where(
        and(
          eq(calendarShares.shareToken, token),
          eq(calendarShares.userId, userId)
        )
      );

    return c.json({ success: true });
  } catch (error) {
    console.error('Error deleting share:', error);
    return c.json({
      success: false,
      error: 'Failed to delete share'
    }, 500);
  }
});
```

**Frontend:**

- Sidebar: Add "Share Calendar" section
- Share dialog: Input name, select permissions, expiry
- Share settings: List active shares with copy link button
- Public calendar view: Read-only calendar by token (optional)

```typescript
// apps/web/src/components/calendar/components/app-sidebar.tsx (enhanced)
<div className="px-2 py-4">
  <h3 className="text-sm font-medium mb-3 px-2">Sharing</h3>
  <Button
    variant="outline"
    size="sm"
    className="w-full"
    onClick={() => setShareDialogOpen(true)}
  >
    <Share2 className="h-4 w-4 mr-2" />
    Share Calendar
  </Button>

  <Button
    variant="ghost"
    size="sm"
    className="w-full"
    onClick={() => setManageSharesOpen(true)}
  >
    <Users className="h-4 w-4 mr-2" />
    Manage Shares
  </Button>
</div>
```

```typescript
// apps/web/src/components/calendar/share-dialog.tsx (new)
export function ShareCalendarDialog({ isOpen, onClose }: DialogProps) {
  const [shareName, setShareName] = useState('');
  const [permissions, setPermissions] = useState({ view: true, edit: false, delete: false });
  const [expiresDays, setExpiresDays] = useState(30);
  const [loading, setLoading] = useState(false);
  const [createdShare, setCreatedShare] = useState<string | null>(null);

  const handleCreateShare = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/calendar/share', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: shareName,
          permissions,
          expiresDays
        })
      });

      const result = await response.json();
      if (result.success) {
        const shareUrl = `${window.location.origin}/calendar/share/${result.data.shareToken}`;
        setCreatedShare(shareUrl);
      }
    } catch (error) {
      console.error('Error creating share:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Share Calendar</DialogTitle>
          <DialogDescription>
            Create a shareable link for your calendar
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          <div>
            <Label>Share Name</Label>
            <Input
              value={shareName}
              onChange={e => setShareName(e.target.value)}
              placeholder="e.g., Work Calendar"
            />
          </div>

          <div>
            <Label>Permissions</Label>
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <Checkbox checked={permissions.view} onCheckedChange={v => setPermissions(p => ({ ...p, view: v }))} />
                <span>View only</span>
              </div>
              <div className="flex items-center gap-2">
                <Checkbox checked={permissions.edit} onCheckedChange={e => setPermissions(p => ({ ...p, edit: e }))} />
                <span>Allow editing</span>
              </div>
              <div className="flex items-center gap-2">
                <Checkbox checked={permissions.delete} onCheckedChange={d => setPermissions(p => ({ ...p, delete: d }))} />
                <span>Allow deleting</span>
              </div>
            </div>
          </div>

          <div>
            <Label>Expires After (Days)</Label>
            <Input
              type="number"
              value={expiresDays}
              onChange={e => setExpiresDays(parseInt(e.target.value))}
              min={1}
              max={365}
            />
          </div>

          <Button
            onClick={handleCreateShare}
            disabled={loading || !shareName}
            className="w-full"
          >
            {loading ? 'Creating...' : 'Create Share Link'}
          </Button>

          {createdShare && (
            <Alert>
              <AlertDescription>
                <div className="flex items-center justify-between gap-2">
                  <span>Share created:</span>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => {
                      navigator.clipboard.writeText(createdShare);
                      toast.success('Link copied to clipboard');
                    }}
                  >
                    <Copy className="h-4 w-4" />
                  </Button>
                </div>
                <a
                  href={createdShare}
                  target="_blank"
                  rel="noopener"
                  className="text-blue-500 hover:underline"
                >
                  {createdShare}
                </a>
              </AlertDescription>
            </Alert>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

**Public Calendar View (Optional):**

```typescript
// apps/web/src/routes/calendar-share.tsx (new)
export const Route = createFileRoute('/calendar/share/$token')({
  component: SharedCalendarView
});

function SharedCalendarView() {
  const { token } = Route.useParams();
  const { data: sharedData, isLoading } = useQuery({
    queryKey: ['shared-calendar', token],
    queryFn: () => fetchSharedCalendar(token)
  });

  if (isLoading) return <LoadingSpinner />;
  if (!sharedData?.canEdit) {
    return (
      <div className="read-only-calendar">
        <Banner>Read-only View</Banner>
        <TaskCalendarGrid
          tasks={sharedData.tasks}
          onDateSelect={(date) => toast.info('This calendar is read-only')}
        />
      </div>
    );
  }

  return (
    <div>
      <SharedCalendarHeader name={sharedData.name} />
      <TaskCalendarGrid
        tasks={sharedData.tasks}
        editable={true}
      />
    </div>
  );
}
```

**Sharing Model Questions:**

- Should shared calendars be:
  - Link-based with optional password?
  - Require recipient account creation?
  - Read-only or allow edits too?
- How to handle task conflicts on shared calendars?

---

### Priority 8: Drag & Drop Task Movement

**Complexity:** Medium-High | **Estimated:** 3-4 days

**Why Last Priority:**

- Rescheduling modal (Priority 1) covers same need
- Higher UX complexity, more edge cases
- Mobile experience challenges

**Implementation:**

- Use `@dnd-kit/core` or `@hello-pangea/dnd`
- Wrap day cells in `Droppable`
- Wrap tasks in `Draggable`
- Handle `onDrop` → call reschedule API (reuses Priority 1 endpoint)

**Key Challenges:**

- Visual feedback during drag (ghost image)
- Prevent drops to invalid cells (e.g., past dates)
- Conflict checking on drop
- Mobile touch support

**UX Considerations:**

- Show clear drop zones on hover
- Highlight target day when dragging over
- Auto-scroll calendar when dragging near edges
- Snap to day grid alignment

**Dependencies:**

```bash
bun add @dnd-kit/core
# or
bun add @hello-pangea/dnd
```

```typescript
// apps/web/src/components/calendar/draggable-calendar-grid.tsx
import { DndContext, DragOverlay } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';

export function DraggableCalendarGrid(props: CalendarGridProps) {
  const [activeTask, setActiveTask] = useState<CalendarTask | null>(null);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragStart = (event: DragStartEvent) => {
    setActiveTask(event.active.data as CalendarTask);
  };

  const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event;
    setActiveTask(null);

    if (!active || !over) return;

    const task = active.data.current as CalendarTask;
    const targetDate = over.data.current as Date;

    // Check if valid drop target
    if (targetDate < new Date()) {
      toast.error('Cannot reschedule to past dates');
      return;
    }

    // Call reschedule API
    try {
      await updateTaskCompletion({
        taskId: task.id,
        newStartTime: targetDate,
        newEndTime: new Date(targetDate.getTime() + (task.endTime.getTime() - task.startTime.getTime()))
      });
      onTaskUpdate?.();
      toast.success('Task rescheduled');
    } catch (error) {
      console.error('Error rescheduling task:', error);
      toast.error('Failed to reschedule task');
    }
  };

  return (
    <DndContext sensors={sensors}>
      <SortableContext
        items={tasks}
        strategy={verticalListSortingStrategy}
        onDragEnd={handleDragEnd}
      >
        <TaskCalendarGrid {...props} />
      </SortableContext>

      <DragOverlay>
        {activeTask ? (
          <div className="bg-background border rounded-lg p-4 shadow-lg">
            <p className="font-medium">{activeTask.taskDescription}</p>
            <p className="text-sm text-muted-foreground">
              {format(activeTask.startTime, 'h:mm a')} - {format(activeTask.endTime, 'h:mm a')}
            </p>
          </div>
        ) : null}
      </DragOverlay>
    </DndContext>
  );
}
```

**Day Cell Drop Zones:**

```typescript
// apps/web/src/components/calendar/day-cell.tsx (new component)
import { useDroppable } from '@dnd-kit/core';

export function DayCell({ date, tasks, onDrop }: DayCellProps) {
  const { setNodeRef, isOver } = useDroppable({
    id: format(date, 'yyyy-MM-dd'),
    data: date
  });

  const handleDrop = (event: DropEvent) => {
    const task = event.active.data as CalendarTask;
    onDrop(task, date);
  };

  return (
    <div
      ref={setNodeRef}
      className={cn(
        "aspect-square border rounded p-2",
        isOver && "ring-2 ring-primary bg-primary/10"
      )}
      onDragOver={(e) => e.preventDefault()}
      onDrop={handleDrop}
    >
      {/* Day content */}
    </div>
  );
}
```

**Mobile Support (If using dnd-kit):**

```typescript
import { TouchSensor } from '@dnd-kit/core';

const sensors = useSensors(
  useSensor(PointerSensor),
  useSensor(TouchSensor, {
    activationConstraint: { distance: 10 },
  }),
  useSensor(KeyboardSensor)
);
```

---

## Recommended V2 Implementation Order

| Phase | Feature | Duration | Dependencies | Risk |
|--------|----------|--------------|-------|
| 1 | Task Rescheduling Modal | 2-3 days | None | Low |
| 2 | Weekly View | 2-3 days | None | Low |
| 3 | Export to .ics | 2 days | None | Low |
| 4 | Task Creation Modal | 3-4 days | **Architecture Decision** | Medium |
| 5 | Task Notes/Attachments | 3-4 days | File storage decision | Medium |
| 6 | Calendar Sharing | 4-5 days | Database schema, auth | Medium |
| 7 | Recurring Tasks | 4-5 days | Database schema, cron job | Medium-High |
| 8 | Drag & Drop | 3-4 days | dnd-kit, Priority 1 | Medium |

**Total Estimated Time: 23-31 days for full V2**

---

## Questions Before Starting V2

1. **Task Architecture:** Option A (add to plans), B (independent), or C (both)?

2. **File Storage:** Where should uploaded attachments be stored?
   - Local `uploads/` directory?
   - AWS S3?
   - Cloudflare R2?
   - Bunny CDN?

3. **Recurring Task Expansion:** Should we use database triggers, a cron job, or expand on-demand?

4. **Sharing Model:** Should shared calendars be:
   - Link-based with optional password?
   - Require recipient account creation?
   - Read-only or allow edits too?

5. **Mobile Priority:** Should we implement Weekly View first for mobile (better density), or focus on full desktop experience?

---

## Technical Debt Considerations

1. **Task Model Complexity:** If we support independent tasks, need to differentiate between:
   - AI-generated plan tasks
   - User-created independent tasks
   - Recurring task expansions

2. **Performance:** Weekly view may need different query optimization (date ranges vs monthly loads)

3. **Testing Requirements:**
   - Unit tests for date calculations (weekly boundaries, recurrence)
   - Integration tests for ICS export (validate with real calendars)
   - Drag & drop E2E tests
   - Share link expiration tests

4. **API Rate Limiting:** Consider rate limits for:
   - ICS exports (prevent abuse)
   - Share creation (prevent spam)

5. **Analytics:** Track feature usage:
   - How often is weekly view used?
   - ICS export frequency?
   - Share creation/deletion rate?
   - Recurring task adoption?
